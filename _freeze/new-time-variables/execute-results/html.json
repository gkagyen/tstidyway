{
  "hash": "0424a2e9d3c1cf5b6acfbbce21c24c1d",
  "result": {
    "engine": "knitr",
    "markdown": "# Creating Useful Time-Based Features {#sec-creating-useful-time-features}\n\n\n\n\n\nNow that you have mastered `lubridate` for date manipulation, it is time to unlock the true power of time series analysis; **`feature engineering`**. Think of your date column as a treasure chest filled with valuable information. Feature engineering is the process of opening that chest and extracting the gems hidden within.\n\nIn this chapter, you will learn how to transform simple dates into powerful predictors that can dramatically improve your forecasting models. We will work with our `sales_data` and `gh_ts` data sets we used in @sec-importing-data-and-creating-a-tsibble and @sec-dealing-with-time-gaps-and-irregularities respectively to create features that capture seasonal patterns, economic cycles and long-term trends relevant to the Ghanaian context.\n\n## Basic Time Based Features\n\nFor this demonstration , we will only the `sales_data` which contains monthly sales from 2015 to 2019.\n\n### Calendar-Based Features\n\nThese are the most straightforward features derived directly from the date component. Here we use the date itself (The Month column) to categorise and enrich the data. This can be crucial for capturing predictable cyclic patterns that repeat yearly, quarterly, or monthly.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Extract basic calender features\nsales_features_basic <- sales_data |> \n  mutate(\n    # Basic date components\n    Year = year(Month),\n    Month_only = month(Month, label = TRUE),\n    Quarter = quarter(Month),\n    \n    # Ghana-specific seasonal features\n    Season = case_when(\n      Month_only %in% month.abb[4:10] ~ 'Rainy Season',\n      Month_only %in% month.abb[c(1,2,12)] ~ \"Dry Season\",\n      TRUE ~ \"Transition\"\n    ),\n    # Holiday/Business cycles\n    is_holiday_season = Month_only %in% month.abb[c(3,12)],  # Most Holiday months  \n    is_back_to_school = Month_only %in% month.abb[9:10],  # Typical start of academic year\n    \n    # economic calender features\n    is_year_start = Month_only == 'Jan',\n    is_year_end = Month_only == 'Dec',\n    is_mid_year = Month_only == 'Jun'\n  )\n```\n:::\n\n\nThe basic date components captures the level of aggregation. Models use these to find **annual trends** or **quarterly seasonality**. The ***Ghana-specific seasonal features***, creates a seasonal flag that may *influence sales (like less travels during heavy rain).* The ***holidays/business cycles**,* and ***economic calender features*** creates a logical (TRUE/FALSE) identifying major holiday periods, periods when schools reopens and end of period effects such as budget finalisation or semi annual targets that influence sales activities.\n\nThis whole process transforms a simple **Date** column into many powerful categorical and numerical features, which a predictive model can easily interpret. This can significantly improve the models ability to forecast.\n\n### Creating Lag Features\n\nLag features are arguably the **most important** feature type for time series analysis. A lag feature is the value of the series at a previous time step. They capture temporal dependence (autocorrelation) â€“ the idea that a value today is highly correlated with its value yesterday, last week or last year.\n\nFor this demonstration we will use the `gh_ts` dataset focusing on some key indicators from the data (Annual GDP growth, Total Population, GDP per-capita in USD and Cereal yield per hectare).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngh_ts_filtered <- gh_ts |> \n  filter(\n    indicator_name %in% c(\"Annual GDP growth rate\", \"Population_total\",\n                          \"GDP per capita usd\",\"Cereal yield _kg per hectare\")\n  )\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Create lag and difference \ngh_ts_lags <- gh_ts_filtered |> \n  group_by(indicator_name) |> \n  mutate(\n    # Lag features (previous values)\n    value_lag1 = lag(value, 1),\n    \n    # Difference features (changes over time)\n    value_diff = value - value_lag1,\n    value_pct_change = (value - value_lag1) / value_lag1 * 100\n  )\n```\n:::\n\n\nThe lag features are calculated using the `lag()` function from the `dplyr` package. The function takes a vector of values (usually a column from a dataframe) and the number of positions to lag. In the code above we shift the values for each indicator by 1 year (`value_lag1`), calculate the difference between the original values and the lagged values (`value_diff`) and then further calculate the **relative year-over-year change** (`value_pct_change`). The differencing helps to remove the level (baseline value) and trend (long term direction) which is a key step in achieving stationarity when fitting an ARIMA model.\n\n::: callout-important\nWhen fitting an ARIMA model (with the `fable` package) you do not need to manually calculate the lag and differencing. The model handles this automatically.\n:::\n\nBy engineering these calendar and lag features for fitting a particular model, the model gains profound understanding of the data's historical movement, leading to significantly more accurate forecasts.\n\n## Feature Selection and Analysis\n\nAfter creating numerous features, the next step is to determine which ones are genuinely useful predictors and should be included in the final model.\n\n### Correlation Analysis\n\nCorrelation measures the linear relationship between two variables. To check feature importance using correlation, we are essentially looking at how strongly each feature is linearly related to the target variable. We can demonstrate this with the `gh_ts_lags` data we just created.\n\nWe will add more features to the data and check how they all relate to the target variable (`value`). The new features will include another lagged value that shifts the `value` 2 time steps back, A binary feature (TRUE/FALSE) for election years since 1960.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create political and economic cycle features \ngh_contextual <- gh_ts_lags |> \n  group_by(indicator_name) |> \n  mutate(\n    # add 2nd lag feature\n    value_lag2 = lag(value, 2),\n    \n    # election cycles\n    election_year = year %in% c(1960, 1969, 1979, seq(1992, 2024, by=4))\n    ) |> \n  ungroup()\n```\n:::\n\n\nWe can now go ahead and check the importance of all these features using their correlation with the original value (`value` column). The data we have has **4 keys**, meaning there are 4 separate time series' within the data. We are going to focus only on the values for the **\"Annual GDP growth rate\"** series.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# correlation analysis of features with GDP growth\ngdp_correlations <- gh_contextual |> \n  filter(indicator_name == \"Annual GDP growth rate\") |> \n  as_tibble() |> \n  select(value, value_lag1, \n         value_diff, value_pct_change, \n         value_lag2, election_year) |> \n  mutate(\n    # recode election_year \n    election_year = case_match(\n      election_year,\n      TRUE ~ 1,\n      FALSE ~ 0\n    )\n  ) |> \n  cor(use = \"complete.obs\")\n```\n:::\n\n\nThe code above calculates the correlation matrix for the selected variables using the `cor()` function. Since the `cor()` function only works on numeric vectors, the `election_year` had to be converted to numeric binary values (0 and 1). The table below shows the correlation of the selected variables with the actual `value`.The features with high correlation (positive or negative) are strong candidates for inclusion in the final forecasting model.\n\n|                      | value |\n|----------------------|-------|\n| **value_lag1**       | 0.372 |\n| **value_diff**       | 0.561 |\n| **value_pct_change** | 0.349 |\n| **value_lag2**       | 0.125 |\n| **election_year**    | 0.085 |\n\n: correlation coefficients of features vs actual value (`value`)\n\n### Visualising Feature Relationships\n\nCreating visuals of your data is the best way to confirm the relationship derived from the correlation analysis and see how the engineered featured relate to the underlying data.\n\n\n::: {.cell layout-align=\"center\" fig_cap='Time Series Plot of GDP Growth for Ghana With Additional Feature Engineered Data spanning a 64 year period'}\n\n```{.r .cell-code}\ngh_contextual |> \n  filter(\n    indicator_name == \"Annual GDP growth rate\"\n  ) |> ggplot(aes(x = date)) +\n  geom_line(aes(y= value, colour = 'Actual GDP'), size = 0.7) +\n  geom_line(aes(y = value_lag1, colour = '1 Time Step Back'), size = 0.7) +\n  geom_point(aes(y = if_else(election_year, value, NA), colour = \"Election Year\"), size = 2.5) +\n  scale_colour_brewer(type = 'qual', palette = 'Set1') +\n  labs(title = 'Ghana GDP Growth with Engineered Features',\n       subtitle = 'Showing lagged values and election year markers',\n       y = 'GDP Growth Rate (%)',\n       x = 'Date',\n       colour = 'Series')\n```\n\n::: {.cell-output-display}\n![](new-time-variables_files/figure-html/fig-gdp-eng-feat-1.png){#fig-gdp-eng-feat fig-align='center' width=672}\n:::\n:::\n\n\nThe above plot displays the **actual GDP growth** line and the lagged (1 time step back) GDP growth line visually confirming their relationship. There is also a large green dot over every data point that corresponds to an `election_year`. This allows you to check if GDP peaks or spikes tends to coincide with these politically charged years.\n\nYour dates are now transformed into a rich set of features that can significantly improve your forecasting model(s). In the next section we will learn how to perform exploratory analysis on our time series data and delve deeper into visualisations to uncover trends and patterns before building our predictive models.\n\n::: callout-tip\nThe `feasts` package makes performing some of these feature engineering very simple and straightforward. We will explore the `feasts` package in the next chapter\n:::\n",
    "supporting": [
      "new-time-variables_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}