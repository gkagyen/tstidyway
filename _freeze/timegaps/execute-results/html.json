{
  "hash": "c0163f5dfea089250c6309bdb4a62f9a",
  "result": {
    "engine": "knitr",
    "markdown": "# Dealing with Time Gaps and Irregularities {#sec-dealing-with-time-gaps-and-irregularities}\n\nReal-world data is messy. Sensors fails, public holidays happen, data does not get entered. This leads to gaps in your time series – missing entries in the index where we expect a measurement. Traditional data frames ignore this, but `tsibble` helps you find and handle them.\n\n\n\n## Why Time Gaps Matter\n\nMany time series models and visualisations assume ***regular spaced data.*** Gaps can lead to errors, misleading plots and inaccurate forecasts.\n\n## How tsibble Helps\n\nWe can check the time gaps in our tsibble using the `scan_gaps` function from the `tsibble` package. This is a very handy function that compares our actual data against a complete regular timeline and tells us exactly what is missing. Other equally useful functions for handling time gaps include `count_gaps` and `has_gaps`.\n\nWe will scan our `gh_ts` tsibble to check if there are gaps. But before that, we will fix the column names with `janitor::clean_names()` to avoid complications later on in our analysis due to the unconventional column names.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngh_ts <- gh_ts |> \n  janitor::clean_names() \n\ngh_ts |> scan_gaps()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 512,864 x 2 [1D]\n# Key:       indicator_name [22]\n  indicator_name         date      \n  <chr>                  <date>    \n1 Annual GDP growth rate 1960-01-02\n2 Annual GDP growth rate 1960-01-03\n3 Annual GDP growth rate 1960-01-04\n4 Annual GDP growth rate 1960-01-05\n5 Annual GDP growth rate 1960-01-06\n# ℹ 512,859 more rows\n```\n\n\n:::\n:::\n\n\nthe scan gaps returns a long list of missing dates. However, this is not true for our data set. We are getting this many gaps because the inner workings of tsibble thinks that the days of all the months a missing, meanwhile our data is not a daily data but a yearly series. This whole misinterpretation comes from the incorrect interval \\[1D\\]. To fix this we can change the date to a year-month format or use the year column as the index and then rescan for gaps\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# fix interval  by assigning index to year\ngh_ts |> \n  as_tsibble(\n    index = year\n  ) |> head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 2 x 6 [1Y]\n# Key:       indicator_name [1]\n  country_name indicator_name         indicator_code     year date       value\n  <chr>        <chr>                  <chr>             <dbl> <date>     <dbl>\n1 Ghana        Annual GDP growth rate NY.GDP.MKTP.KD.ZG  1960 1960-01-01 NA   \n2 Ghana        Annual GDP growth rate NY.GDP.MKTP.KD.ZG  1961 1961-01-01  3.43\n```\n\n\n:::\n:::\n\n\nHere we see that the interval is now correctly represented a \\[1Y\\] which is exactly what we expect. We do not want to change our index variable so what we will do is keep the date as index but modify it somehow for it to be recognised as a year interval.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngh_ts <- gh_ts |> \n  mutate(date = yearmonth(date))\n\ngh_ts |> head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 3 x 6 [12M]\n# Key:       indicator_name [1]\n  country_name indicator_name         indicator_code     year     date value\n  <chr>        <chr>                  <chr>             <dbl>    <mth> <dbl>\n1 Ghana        Annual GDP growth rate NY.GDP.MKTP.KD.ZG  1960 1960 Jan NA   \n2 Ghana        Annual GDP growth rate NY.GDP.MKTP.KD.ZG  1961 1961 Jan  3.43\n3 Ghana        Annual GDP growth rate NY.GDP.MKTP.KD.ZG  1962 1962 Jan  4.11\n```\n\n\n:::\n:::\n\n\nOur interval is \\[12M\\]-meaning 12 months, essentially indicating a year. We can go ahead and check for gaps now.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngh_ts |> scan_gaps()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 0 x 2 [?]\n# Key:       indicator_name [0]\n# ℹ 2 variables: indicator_name <chr>, date <mth>\n```\n\n\n:::\n:::\n\n\nThis returns an empty tsibble, telling us that there are no time gaps. we can confirm again with the `has_gaps()` function.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngh_ts |> has_gaps() |> \n  pull(.gaps) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nConfirms **Zero Gaps** in our `gh_ts` data!\n\n## Handling Time Gaps\n\nIn order for us to understand the concept of time gaps and how to handle to properly I will simulate a data with implicit time gaps and then we will see how to deal with them using functions from the `tsibble` package\n\nWe will use the same product sales concept to simulate this series. Here we compare sales for 2 products `Smart Phone` and `Laptop` over a 12 month period\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a sequence of sales dates\nstart_date <- ym('2025-01')  \nend_date <- ym('2025-12')\nsales_period <- seq.Date(\n  from = start_date,\n  to = end_date,\n  by = 'month'\n) |> \n  yearmonth()     # change format to year-month\n\n# simulate data with missing dates for different products\nsales_data_gaps <- tsibble(\n  Product = c(rep('Smart Phone', 10), rep('Laptop', 8)),\n  Sales = round(c(rnorm(10,300,65), runif(8, 620, 1000))),\n  Date = c(\n    sales_period[c(1:5,8:12)],      # Smart phone is missing Jun & Jul\n    sales_period[c(2,3,4,5,6,9:11)] # Laptop is missing Jan, Jul, Aug & Dec\n  ),\n  index = Date,\n  key = Product\n)\n\nprint(sales_data_gaps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 18 x 3 [1M]\n# Key:       Product [2]\n  Product Sales     Date\n  <chr>   <dbl>    <mth>\n1 Laptop    771 2025 Feb\n2 Laptop    923 2025 Mar\n3 Laptop    699 2025 Apr\n4 Laptop    670 2025 May\n5 Laptop    968 2025 Jun\n# ℹ 13 more rows\n```\n\n\n:::\n:::\n\n\nOur simulated tsibble (`sales_data_gaps`) is now ready. I visual inspection of the `Date` column will reveal that there are missing dates (implicit). we can confirm this with the functions we learnt earlier and then decide what to do later.\n\n::: callout-note\nMore information on the `seq.Date` function in (@sec-using-lubridate-for-date-manipulation)\n:::\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nscan_gaps(sales_data_gaps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 4 x 2 [1M]\n# Key:       Product [2]\n  Product         Date\n  <chr>          <mth>\n1 Laptop      2025 Jul\n2 Laptop      2025 Aug\n3 Smart Phone 2025 Jun\n4 Smart Phone 2025 Jul\n```\n\n\n:::\n:::\n\n\nThe scan gaps tells us the gaps in our data. Notice how it is only showing only **2 months** are missing for `Laptop` even though we know there are **4 months** missing rather. We will see how to handle this very soon.\n\n::: callout-important\nThe tsibble assumes that our data only starts from **Feb** and Ends in **Nov** for the `Laptop` **Product**.\n:::\n\nThe `tsibble` package makes it really easy to handle gaps in our time series data with the `fill_gaps()` function. The `fill_gaps()` makes the **implicit** gaps **explicit** by inserting rows for missing time periods and assigning `NA` to the observation values (the `Sales` column in our case)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# fill in the missing time points \nsales_data_gaps |> \n  fill_gaps() |> pull(Date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<yearmonth[22]>\n [1] \"2025 Feb\" \"2025 Mar\" \"2025 Apr\" \"2025 May\" \"2025 Jun\" \"2025 Jul\"\n [7] \"2025 Aug\" \"2025 Sep\" \"2025 Oct\" \"2025 Nov\" \"2025 Jan\" \"2025 Feb\"\n[13] \"2025 Mar\" \"2025 Apr\" \"2025 May\" \"2025 Jun\" \"2025 Jul\" \"2025 Aug\"\n[19] \"2025 Sep\" \"2025 Oct\" \"2025 Nov\" \"2025 Dec\"\n```\n\n\n:::\n:::\n\n\nThe `fill_gaps()` function filled only the gaps which were identified by the `scan_gaps` function evidenced by only **22 time points** instead of **24**.\n\nSo you might be wondering, how do we deal with the missing Jan and Dec. Well! the `fill_gaps()` function creates provision for such cases. The function can even help us set a start/ending time that allows us to expand the existing time span (we are not doing that).\n\nBack to our issue, we can set `.full = TRUE` inside `fill_gaps` to fill the time gaps over the entire time span of our data. What it does is, it checks the time span for the `Smart Phone`'s series and notices that it starts from Jan and ends in Dec so it applies the same time span to `Laptops`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# fill gaps over entire time span\nsales_data_filled <- sales_data_gaps |> \n  fill_gaps(.full = TRUE)\n```\n:::\n\n\nAlso, instead of assigning the values of the filled time gaps with `NAs` we can specify a value of our choosing which is very useful if we want to record zero (0) sales for the missing months instead of missing data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# fill gaps in Sales column with 0\nsales_data_gaps |> \n  fill_gaps(\n    .full = TRUE,\n    Sales = 0\n  )\n```\n:::\n\n\nNow, all missing time points have a Sales value of 0 instead of NA. This can be crucial for consistent time series modelling or calculations. Sometimes too the data might not have time gaps but rather missing values for a particular time period. We can deal with them by filtering out complete cases (which automatically introduces time gaps) or use models that can handle `NA`s within a time series data. The later choice would not help much. Since we will not go into imputing missing data my advice is to rely on the `fill_gaps()` and replacing `NA`s with **zeros**.\n\n::: callout-tip\nthe `imputeTS` package provides several robust methods for estimating missing values in a time series data.\n:::\n\n::: callout-caution\nAlways apply domain knowledge and check time series data characteristics before applying a particular imputation method from `imputeTS`\n:::\n\nThe next chapter is a bonus one. It briefly describes how to import data (time series data) into R from various sources with a simple code illustration. You can decide to skip it if you already know how to import the data from some common file formats like `.csv` or `.xlsx` (excel file) into R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}